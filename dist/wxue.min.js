'use strict'; function e () {} function t (e) { return e && typeof e === 'function' } function n (e) { return e && typeof e === 'object' } function o (e) { return Array.isArray(e) } function r (e, t) { o(e) ? e.forEach(t) : n(e) && Object.keys(e).forEach(n => { t(e[n], n) }) }Object.defineProperty(exports, '__esModule', { value: !0 }); const s = new class {constructor () { this.queue = [] }push (e) { this.queue.push(e) }run (e) { for (;this.queue.length;)e(this.queue.shift()) }isNull () { return this.queue.length === 0 }}(); let c = null; let u = null; function i (e, t) { s.push(t), u && (clearTimeout(u), u = null), u = setTimeout(() => { if (s.isNull()) return; let t = {}; s.run(e => { t = { ...t, ...e } }), e.setData(t, () => { c && (c(), c = null) }) }) } const l = ['onLoad', 'onReady', 'onShow', 'onHide', 'onUnload', 'onPullDownRefresh', 'onReachBottom', 'onShareAppMessage']; let a = null; function f (t) { l.forEach(n => { const o = t[n] || e; t[n] = function (e) { h(n, e, this), o(e) } }) } function h (e, t, n) { const o = n.__hooks__[e]; if (o && o.length) for (let e = 0; e < o.length; e++)o[e](t) } function p (e) { var t; a = e, a.__hooks__ = {}, t = a, ['__hooks__'].forEach(e => { Object.defineProperty(t, e, { enumerable: !1 }) }), l.forEach(e => { a.__hooks__[e] = [] }) } function _ (e) { return function (t) { a.__hooks__[e].push(t) } } const d = _('onLoad'); const v = _('onReady'); const g = _('onShow'); const y = _('onHide'); const x = _('onUnload'); const R = _('onPullDownRefresh'); const w = _('onReachBottom'); const b = _('onShareAppMessage'); function m (e, t) { const n = Object.create(null); const o = e.split(','); for (let e = 0; e < o.length; e++)n[o[e]] = !0; return t ? e => !!n[e.toLowerCase()] : e => !!n[e] } const S = {}; const k = () => {}; const E = Object.assign; const P = Object.prototype.hasOwnProperty; const O = (e, t) => P.call(e, t); const j = Array.isArray; const M = e => typeof e === 'function'; const z = e => typeof e === 'symbol'; const A = e => e !== null && typeof e === 'object'; const L = Object.prototype.toString; const H = e => (e => L.call(e))(e).slice(8, -1); const q = (e, t) => e !== t && (e == e || t == t); const D = (e, t, n) => { Object.defineProperty(e, t, { configurable: !0, enumerable: !1, value: n }) }; const W = new WeakMap(); const B = []; let K; const N = Symbol(''); const T = Symbol(''); function U (e, t = S) { (function (e) { return e && !0 === e._isEffect })(e) && (e = e.raw); const n = (function (e, t) { const n = function () { if (!n.active) return t.scheduler ? void 0 : e(); if (!B.includes(n)) { !(function (e) { const { deps: t } = e; if (t.length) { for (let n = 0; n < t.length; n++)t[n].delete(e); t.length = 0 } }(n)); try { return I.push(F), F = !0, B.push(n), K = n, e() } finally { B.pop(), (function () { const e = I.pop(); F = void 0 === e || e }()), K = B[B.length - 1] } } }; return n.id = C++, n._isEffect = !0, n.active = !0, n.raw = e, n.deps = [], n.options = t, n }(e, t)); return t.lazy || n(), n } let C = 0; let F = !0; const I = []; function G (e, t, n) { if (!F || void 0 === K) return; let o = W.get(e); o || W.set(e, o = new Map()); let r = o.get(n); r || o.set(n, r = new Set()), r.has(K) || (r.add(K), K.deps.push(r)) } function J (e, t, n, o, r, s) { const c = W.get(e); if (!c) return; const u = new Set(); const i = e => { e && e.forEach(e => u.add(e)) }; if (t === 'clear')c.forEach(i); else if (n === 'length' && j(e))c.forEach((e, t) => { (t === 'length' || t >= o) && i(e) }); else { void 0 !== n && i(c.get(n)); const o = t === 'add' || t === 'delete' && !j(e); (o || t === 'set' && e instanceof Map) && i(c.get(j(e) ? 'length' : N)), o && e instanceof Map && i(c.get(T)) }u.forEach(e => { e.options.scheduler ? e.options.scheduler(e) : e() }) } const Q = new Set(Object.getOwnPropertyNames(Symbol).map(e => Symbol[e]).filter(z)); const V = ee(); const X = ee(!1, !0); const Y = ee(!0); const Z = ee(!0, !0); const $ = {}; function ee (e = !1, t = !1) { return function (n, o, r) { if (o === '__v_isReactive') return !e; if (o === '__v_isReadonly') return e; if (o === '__v_raw' && r === (e ? n.__v_readonly : n.__v_reactive)) return n; const s = j(n); if (s && O($, o)) return Reflect.get($, o, r); const c = Reflect.get(n, o, r); return (z(o) ? Q.has(o) : o === '__proto__' || o === '__v_isRef') ? c : (e || G(n, 0, o), t ? c : Be(c) ? s ? c : c.value : A(c) ? e ? Ae(c) : ze(c) : c) } }['includes', 'indexOf', 'lastIndexOf'].forEach(e => { $[e] = function (...t) { const n = De(this); for (let e = 0, t = this.length; e < t; e++)G(n, 0, e + ''); const o = n[e](...t); return o === -1 || !1 === o ? n[e](...t.map(De)) : o } }); function te (e = !1) { return function (t, n, o, r) { const s = t[n]; if (!e && (o = De(o), !j(t) && Be(s) && !Be(o))) return s.value = o, !0; const c = O(t, n); const u = Reflect.set(t, n, o, r); return t === De(r) && (c ? q(o, s) && J(t, 'set', n, o) : J(t, 'add', n, o)), u } } function ne (e, t) { const n = Reflect.has(e, t); return z(t) && Q.has(t) || G(e, 0, t), n } function oe (e) { return G(e, 0, N), Reflect.ownKeys(e) } const re = { get: V, set: te(), deleteProperty: function (e, t) { const n = O(e, t); const o = (e[t], Reflect.deleteProperty(e, t)); return o && n && J(e, 'delete', t, void 0), o }, has: ne, ownKeys: oe }; const se = { get: Y, has: ne, ownKeys: oe, set: (e, t) => !0, deleteProperty: (e, t) => !0 }; const ce = E({}, re, { get: X, set: te(!0) }); const ue = E({}, se, { get: Z }); const ie = e => A(e) ? ze(e) : e; const le = e => A(e) ? Ae(e) : e; const ae = e => e; const fe = e => Reflect.getPrototypeOf(e); function he (e, t, n) { e = De(e); const o = De(t); t !== o && G(e, 0, t), G(e, 0, o); const { has: r, get: s } = fe(e); return r.call(e, t) ? n(s.call(e, t)) : r.call(e, o) ? n(s.call(e, o)) : void 0 } function pe (e) { const t = De(this); const n = De(e); e !== n && G(t, 0, e), G(t, 0, n); const o = fe(t).has; return o.call(t, e) || o.call(t, n) } function _e (e) { return G(e = De(e), 0, N), Reflect.get(fe(e), 'size', e) } function de (e) { e = De(e); const t = De(this); const n = fe(t); const o = n.has.call(t, e); const r = n.add.call(t, e); return o || J(t, 'add', e, e), r } function ve (e, t) { t = De(t); const n = De(this); const { has: o, get: r, set: s } = fe(n); let c = o.call(n, e); c || (e = De(e), c = o.call(n, e)); const u = r.call(n, e); const i = s.call(n, e, t); return c ? q(t, u) && J(n, 'set', e, t) : J(n, 'add', e, t), i } function ge (e) { const t = De(this); const { has: n, get: o, delete: r } = fe(t); let s = n.call(t, e); s || (e = De(e), s = n.call(t, e)); o && o.call(t, e); const c = r.call(t, e); return s && J(t, 'delete', e, void 0), c } function ye () { const e = De(this); const t = e.size !== 0; const n = fe(e).clear.call(e); return t && J(e, 'clear', void 0, void 0), n } function xe (e, t) { return function (n, o) { const r = this; const s = De(r); const c = e ? le : t ? ae : ie; return !e && G(s, 0, N), fe(s).forEach.call(s, function (e, t) { return n.call(o, c(e), c(t), r) }) } } function Re (e, t, n) { return function (...o) { const r = De(this); const s = r instanceof Map; const c = e === 'entries' || e === Symbol.iterator && s; const u = e === 'keys' && s; const i = fe(r)[e].apply(r, o); const l = t ? le : n ? ae : ie; return !t && G(r, 0, u ? T : N), { next () { const { value: e, done: t } = i.next(); return t ? { value: e, done: t } : { value: c ? [l(e[0]), l(e[1])] : l(e), done: t } }, [Symbol.iterator] () { return this } } } } function we (e) { return function (...t) { return e !== 'delete' && this } } const be = { get (e) { return he(this, e, ie) }, get size () { return _e(this) }, has: pe, add: de, set: ve, delete: ge, clear: ye, forEach: xe(!1, !1) }; const me = { get (e) { return he(this, e, ae) }, get size () { return _e(this) }, has: pe, add: de, set: ve, delete: ge, clear: ye, forEach: xe(!1, !0) }; const Se = { get (e) { return he(this, e, le) }, get size () { return _e(this) }, has: pe, add: we('add'), set: we('set'), delete: we('delete'), clear: we('clear'), forEach: xe(!0, !1) }; function ke (e, t) { const n = t ? me : e ? Se : be; return (t, o, r) => o === '__v_isReactive' ? !e : o === '__v_isReadonly' ? e : o === '__v_raw' ? t : Reflect.get(O(n, o) && o in t ? n : t, o, r) }['keys', 'values', 'entries', Symbol.iterator].forEach(e => { be[e] = Re(e, !1, !1), Se[e] = Re(e, !0, !1), me[e] = Re(e, !1, !0) }); const Ee = { get: ke(!1, !1) }; const Pe = { get: ke(!1, !0) }; const Oe = { get: ke(!0, !1) }; const je = new Set([Set, Map, WeakMap, WeakSet]); const Me = m('Object,Array,Map,Set,WeakMap,WeakSet'); function ze (e) { return e && e.__v_isReadonly ? e : Le(e, !1, re, Ee) } function Ae (e) { return Le(e, !0, se, Oe) } function Le (e, t, n, o) { if (!A(e)) return e; if (e.__v_raw && (!t || !e.__v_isReactive)) return e; const r = t ? '__v_readonly' : '__v_reactive'; if (O(e, r)) return e[r]; if ((s = e).__v_skip || !Me(H(s)) || Object.isFrozen(s)) return e; var s; const c = new Proxy(e, je.has(e.constructor) ? o : n); return D(e, r, c), c } function He (e) { return qe(e) ? He(e.__v_raw) : !(!e || !e.__v_isReactive) } function qe (e) { return !(!e || !e.__v_isReadonly) } function De (e) { return e && De(e.__v_raw) || e } const We = e => A(e) ? ze(e) : e; function Be (e) { return !!e && !0 === e.__v_isRef } function Ke (e, t = !1) { if (Be(e)) return e; let n = t ? e : We(e); const o = { __v_isRef: !0, get value () { return G(o, 0, 'value'), n }, set value (r) { q(De(r), e) && (e = r, n = t ? r : We(r), J(o, 'set', 'value', r)) } }; return o } function Ne (e) { return Be(e) ? e.value : e } const Te = { get: (e, t, n) => Ne(Reflect.get(e, t, n)), set: (e, t, n, o) => { const r = e[t]; return Be(r) && !Be(n) ? (r.value = n, !0) : Reflect.set(e, t, n, o) } }; function Ue (e, t) { return { __v_isRef: !0, get value () { return e[t] }, set value (n) { e[t] = n } } } function Ce (e) { e.active && (!(function (e) { const { deps: t } = e; if (t.length) { for (let n = 0; n < t.length; n++)t[n].delete(e); t.length = 0 } }(e)), e.options.onStop && e.options.onStop(), e.active = !1) } function Fe (e) { e && t(e) || console.warn('watchEffect fn 应该是个函数'), e && !t(e) && (e = null); const n = U(e); return () => { Ce(n) } } const Ie = o => { if (t(o.setup)) { let s = o.onLoad || e; f(o), o.onLoad = function (e) { p(this), (function (e, o) { const s = e.setup(o) || {}; const c = {}; r(s, (n, o) => { t(n) ? e[o] = n : c[o] = n }), (function e (t, o, s) { r(o, (r, c) => { const u = s ? s + '.' + c : c; n(r) && !Be(r) && e(t, r, u), U(() => { const e = o[c]; const n = (Be(e), u); const r = Be(e) ? Ne(e) : De(e); i(t, { [n]: r }) }) }) }(e, c)) }(this, e)), h('onLoad', e, this), s = s.bind(this), s(e) } } return Page(o) }; exports.callHooks = h, exports.computed = function (e) { let t, n; M(e) ? (t = e, n = k) : (t = e.get, n = e.set); let o; let r; let s = !0; const c = U(t, { lazy: !0, scheduler: () => { s || (s = !0, J(r, 'set', 'value')) } }); return r = { __v_isRef: !0, __v_isReadonly: M(e) || !e.set, effect: c, get value () { return s && (o = c(), s = !1), G(r, 0, 'value'), o }, set value (e) { n(e) } }, r }, exports.customRef = function (e) { const { get: t, set: n } = e(() => G(o, 0, 'value'), () => J(o, 'set', 'value')); const o = { __v_isRef: !0, get value () { return t() }, set value (e) { n(e) } }; return o }, exports.effect = U, exports.initHooks = p, exports.isProxy = function (e) { return He(e) || qe(e) }, exports.isReactive = He, exports.isReadonly = qe, exports.isRef = Be, exports.markRaw = function (e) { return D(e, '__v_skip', !0), e }, exports.nextTick = e => new Promise(t => { c = () => { e && e(), t() } }), exports.onHide = y, exports.onLoad = d, exports.onPullDownRefresh = R, exports.onReachBottom = w, exports.onReady = v, exports.onShareAppMessage = b, exports.onShow = g, exports.onUnload = x, exports.proxyRefs = function (e) { return He(e) ? e : new Proxy(e, Te) }, exports.reactive = ze, exports.readonly = Ae, exports.ref = function (e) { return Ke(e) }, exports.resolveHooks = f, exports.setData = i, exports.shallowReactive = function (e) { return Le(e, !1, ce, Pe) }, exports.shallowReadonly = function (e) { return Le(e, !0, ue, Oe) }, exports.shallowRef = function (e) { return Ke(e, !0) }, exports.stop = Ce, exports.toRaw = De, exports.toRef = Ue, exports.toRefs = function (e) { const t = {}; for (const n in e)t[n] = Ue(e, n); return t }, exports.triggerRef = function (e) { J(e, 'set', 'value', void 0) }, exports.unref = Ne, exports.watch = function (n, r) { let s = o(n) ? n.map(() => {}) : void 0; return Fe(() => { const c = (function (n) { let r = e; Be(n) ? r = () => n.value : t(n) ? r = () => n() : o(n) && (r = () => n.map(e => Be(e) ? e.value : t(e) ? e() : void 0)); return r() }(n)); c && r(c, s), s = c }) }, exports.watchEffect = Fe, exports.wxue = Ie
